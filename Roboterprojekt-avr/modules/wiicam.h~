

//SERVO
#define MAX_SERVOS 1
#define LEFT MIDDLE-220
#define MIDDLE 350
#define RIGHT MIDDLE+220
#define PERIOD 4000

/*
*IR RECEIVER
*/
#define RC5TIME     1.778e-3        // 1.778msec
#define    XTAL        16.0E6
#define PULSE_MIN    (unsigned char)(XTAL / 512 * RC5TIME * 0.2 + 0.5)
#define PULSE_1_2    (unsigned char)(XTAL / 512 * RC5TIME * 0.8 + 0.5)
#define PULSE_MAX    (unsigned char)(XTAL / 512 * RC5TIME * 1.2 + 0.5)





//IR RECEIVER
bit              rc5_bit=1;            // bit value
unsigned char rc5_time=0;            // count bit time
unsigned int  rc5_data=0;            // store result  
unsigned int  tmp;

unsigned char ucToggle;                         
unsigned char ucAdress;                         
unsigned char ucData;

char s[17];



// Globale Variablen für Servo
signed char arTrim[MAX_SERVOS] = {0};
unsigned int arServos[MAX_SERVOS] = {MIDDLE};
unsigned int Pause = PERIOD;
int ucServoNr = 0;
int ucNr = 0;

char strTemp[17] = "";
bit bChange = 1;
bit bPause = 0;
bit bMerk=1;
bit inSERVOTEST=0;




  //////////////SERVO/////////////
//Ändert die Position des Servos
void fnSetServo(unsigned char ucNr, unsigned char ucValue)
{
  arServos[ucNr] = ucValue;  
}
//Zeigt die Position des Servos
void fnDisplay(void )
{
 char str[10];
  lcd_clear();  
  lcd_puts("POSITION-SERVO");      
  lcd_gotoxy(0, 1);
  itoa(arServos[ucNr]-MIDDLE, strTemp);
  lcd_puts(strTemp);  
}
// Timer 0 overflow interrupt service routine
interrupt [TIM0_OVF] void timer0_ovf_isr(void)
{
  // Reinitialize Timer 0 value 
  //SERVO
  TCNT0=131;
  if(!BUMPER_RIGHT&&inSERVOTEST==1){ 
  if((arServos[ucNr] <= 570)&&(arServos[ucNr] >=119)){      
    delay_ms(250); 
    arServos[ucNr] += 10;
    bChange = 1;
   }else {
    delay_ms(250); 
    arServos[ucNr] -= 450;
    bChange = 1;
     }
  }        
  
  
  //IR RECIVER
  TCNT0 = 254;                                    // 2 * 256 = 512 cycle
  if( ++rc5_time > PULSE_MAX )                  // count pulse time
  {            
    if( !(tmp & 0x4000) && (tmp & 0x2000) )        // only if 14 bits received
      rc5_data = tmp;
      tmp = 0;
  }
  if (rc5_bit != REMOTE_CONTROL)                       // change detect
  {     
      rc5_bit = !rc5_bit;                        // 0x00 -> 0xFF -> 0x00
      if( rc5_time < PULSE_MIN )                // too short
      tmp = 0;
    if( !tmp || rc5_time > PULSE_1_2 )          // start or long pulse time
    {    
      if( !(tmp & 0x4000) )                        // not to many bits
      tmp = tmp << 1;                            // shift
      if(!rc5_bit)                                // inverted bit
      tmp = tmp | 1;                            // insert new bit
      rc5_time = 0;                                // count next pulse time
    }
  }
  
 } 
  
  
                                    

  //////////////SERVO/////////////
// Timer1 output compare A interrupt service routine
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
//SERVO
  if (!bPause)
  {
    OCR1A = arServos[ucServoNr]+arTrim[ucServoNr];
    SERVO = (1<<ucServoNr);
    Pause -= OCR1A;
    if (++ucServoNr>=MAX_SERVOS)
    {
      ucServoNr = 0;
      bPause = 1;
    } 
  }
  else            
  {
    OCR1A = Pause;
    SERVO = 0;
    bPause = 0;
    Pause = PERIOD;
  }   
}



  //////////////IR RECEIVER///////////// 
                 
int rc5_receive(unsigned char *ucToggle, unsigned char *ucAdress, unsigned char *ucData)
{
  unsigned int i;
    
  #asm("cli")
  i = rc5_data;                                // read two bytes from interrupt !
  rc5_data = 0;
  #asm("sei")  
  if( i )
  {               
    *ucToggle = i >> 11 & 1;
    *ucAdress = i >> 6 & 0x1F; 
    *ucData = (i & 0x3F) | (~i >> 7 & 0x40);    
    return i;
  }   
  else
    return 0;
}  



  //////////////IR RECEIVER/////////////
void rc5_display(void)
{
  //lcd_clear();
 // lcd_gotoxy(0,0);
  puts("IR-DATA");  
  lcd_gotoxy(0,1);
  lcd_putchar('0'+ucToggle);	            // Toggle Bit
  lcd_putchar(' ');
  itoa(ucAdress , s);	                    // Device address
  lcd_puts(s);
  lcd_putchar(' ');
  itoa(ucData, s);                          // Key Code
  lcd_puts(s);   
}



  
  
                   